[
  {
    "project": "youtube-dl",
    "bug": "1",
    "file": "youtube_dl/utils.py",
    "actual_function": [
      "_match_one"
    ],
    "given_functions": [
      "test_match_str",
      "match_str",
      "_match_one",
      "parse_filesize",
      "lookup_unit_table"
    ],
    "changes_function_class_names": [
      "_match_one"
    ],
    "change": [
      "def _match_one(filter_part, dct):\n    COMPARISON_OPERATORS = {\n        '<': operator.lt,\n        '<=': operator.le,\n        '>': operator.gt,\n        '>=': operator.ge,\n        '=': operator.eq,\n        '!=': operator.ne,\n    }\n    operator_rex = re.compile(r'''(?x)\\s*\n        (?P<key>[a-z_]+)\n        \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\\s*\n        (?:\n            (?P<intval>[0-9.]+(?:[kKmMgGtTpPeEzZyY]i?[Bb]?)?)|\n            (?P<quote>[\"\\'])(?P<quotedstrval>(?:\\\\.|(?!(?P=quote)|\\\\).)+?)(?P=quote)|\n            (?P<strval>(?![0-9.])[a-z0-9A-Z]*)\n        )\n        \\s*$\n        ''' % '|'.join(map(re.escape, COMPARISON_OPERATORS.keys())))\n    m = operator_rex.search(filter_part)\n    if m:\n        op = COMPARISON_OPERATORS[m.group('op')]\n        actual_value = dct.get(m.group('key'))\n        # Determine comparison_value (string vs numeric)\n        if (m.group('quotedstrval') is not None or\n            m.group('strval') is not None or\n            actual_value is not None and m.group('intval') is not None and\n                isinstance(actual_value, compat_str)):\n            if m.group('op') not in ('=', '!='):\n                raise ValueError(\n                    'Operator %s does not support string values!' % m.group('op'))\n            comparison_value = m.group('quotedstrval') or m.group('strval') or m.group('intval')\n            quote = m.group('quote')\n            if quote is not None:\n                comparison_value = comparison_value.replace(r'\\%s' % quote, quote)\n        else:\n            try:\n                comparison_value = int(m.group('intval'))\n            except (ValueError, TypeError):\n                comparison_value = parse_filesize(m.group('intval'))\n                if comparison_value is None:\n                    comparison_value = parse_filesize(m.group('intval') + 'B')\n                if comparison_value is None:\n                    raise ValueError(\n                        'Invalid integer value %r in filter part %r' % (\n                            m.group('intval'), filter_part))\n        if actual_value is None:\n            return m.group('none_inclusive')\n        return op(actual_value, comparison_value)\n\n    # Unary (existence/negation) operators\n    operator_rex = re.compile(r'''(?x)\\s*\n        (?P<op>%s)\\s*(?P<key>[a-z_]+)\n        \\s*$\n        ''' % '|'.join(map(re.escape, ('', '!'))))\n    m = operator_rex.search(filter_part)\n    if m:\n        op_str = m.group('op')\n        actual_value = dct.get(m.group('key'))\n        if op_str == '':\n            # Bare key: False if missing; if boolean, use its truthness; otherwise any present value passes.\n            if actual_value is None:\n                return False\n            if isinstance(actual_value, bool):\n                return actual_value\n            return True\n        else:\n            # '!' operator: invert the bare\u2010key result\n            if actual_value is None:\n                return True\n            if isinstance(actual_value, bool):\n                return not actual_value\n            return False\n\n    raise ValueError('Invalid filter part %r' % filter_part)"
    ]
  },
  {
    "project": "youtube-dl",
    "bug": "2",
    "file": "youtube_dl/extractor/common.py",
    "actual_function": [
      "InfoExtractor"
    ],
    "given_functions": [],
    "changes_function_class_names": [],
    "change": []
  },
  {
    "project": "youtube-dl",
    "bug": "3",
    "file": "youtube_dl/utils.py",
    "actual_function": [
      "unescapeHTML"
    ],
    "given_functions": [],
    "changes_function_class_names": [],
    "change": []
  },
  {
    "project": "youtube-dl",
    "bug": "4",
    "file": "youtube_dl/jsinterp.py",
    "actual_function": [
      "JSInterpreter"
    ],
    "given_functions": [],
    "changes_function_class_names": [
      "interpret_expression"
    ],
    "change": [
      "def interpret_expression(self, expr, local_vars, allow_recursion):\n    expr = expr.strip()\n    if expr == '':\n        return ''\n\n    # String literals\n    if expr[0] in ('\"', \"'\") and expr[-1] == expr[0]:\n        return expr[1:-1]\n\n    # Numeric literals\n    if re.match(r'^0x[0-9a-fA-F]+$', expr):\n        return int(expr, 16)\n    if re.match(r'^[0-9]+(\\.[0-9]*)?$', expr):\n        return float(expr) if '.' in expr else int(expr)\n\n    # Boolean literals\n    if expr == 'true':\n        return True\n    if expr == 'false':\n        return False\n\n    # null and undefined\n    if expr in ('null', 'undefined'):\n        return None\n\n    # Regular expression literal\n    if expr.startswith('/') and expr.endswith('/'):\n        return re.compile(expr[1:-1])\n\n    # Array literal\n    if expr.startswith('[') and expr.endswith(']'):\n        inner = expr[1:-1].strip()\n        if not inner:\n            return []\n        parts = self._split_args(inner)  # reuse existing JS\u2010aware splitter\n        return [self.interpret_expression(p, local_vars, allow_recursion) for p in parts]\n\n    # Object literal\n    if expr.startswith('{') and expr.endswith('}'):\n        # existing object\u2010literal handling...\n        return self._eval_object_literal(expr, local_vars, allow_recursion)\n\n    # Function expression\n    if expr.startswith('function'):\n        return self._eval_function_expr(expr, local_vars)\n\n    # \u2014\u2014\u2014 New block to handle simple calls like x(arg1, arg2, \u2026) \u2014\u2014\u2014\n    m = re.match(r'^([A-Za-z_$][\\w$]*)\\((.*)\\)$', expr)\n    if m:\n        name, args_str = m.group(1), m.group(2)\n        if args_str.strip() == '':\n            args_list = []\n        else:\n            # split on commas at the top level (no nested commas)\n            args_list = [a.strip() for a in args_str.split(',')]\n        # Evaluate each argument\n        arg_vals = [\n            self.interpret_expression(arg, local_vars, allow_recursion)\n            for arg in args_list\n        ]\n        # Look up the function: first in local_vars, then in named JS functions\n        func = local_vars.get(name) or self._functions.get(name)\n        if func is None:\n            raise ExtractorError(\"Undefined JS function %r\" % name)\n        # Call it, passing the current variable scope so that closures/locals work\n        return func(arg_vals, local_vars)\n\n    # Identifier lookup (variables, globals, declared functions)\n    if re.match(r'^[A-Za-z_$][\\w$]*$', expr):\n        if expr in local_vars:\n            return local_vars[expr]\n        if expr in self._global_vars:\n            return self._global_vars[expr]\n        if expr in self._functions:\n            return self._functions[expr]\n        raise ExtractorError(\"Unknown JS variable %r\" % expr)\n\n    # If we get here, it really was an unsupported call/expression\n    raise ExtractorError(\"Unsupported JS function call %r\" % expr)"
    ]
  },
  {
    "project": "youtube-dl",
    "bug": "5",
    "file": "youtube_dl/utils.py",
    "actual_function": [
      "unified_timestamp"
    ],
    "given_functions": [
      "test_unified_timestamps",
      "unified_timestamp",
      "extract_timezone",
      "date_formats"
    ],
    "changes_function_class_names": [
      "unified_timestamp"
    ],
    "change": [
      "def unified_timestamp(date_str, day_first=True):\n    if date_str is None:\n        return None\n\n    # Replace commas so that strptime patterns don't have to expect them\n    date_str = date_str.replace(',', ' ')\n\n    # Detect PM unambiguously by upper-casing\n    has_pm = 'PM' in date_str.upper()\n    pm_delta = datetime.timedelta(hours=12 if has_pm else 0)\n\n    # Extract any numeric timezone offset (e.g. \"+0200\", \"Z\") and strip it\n    timezone, date_str = extract_timezone(date_str)\n\n    # Remove AM/PM markers and any trailing LETTER timezone (e.g. \" PST\")\n    date_str = re.sub(r'(?i)\\s*(?:AM|PM)(?:\\s+[A-Z]+)?', '', date_str)\n\n    # Try all the strptime formats first\n    for expression in date_formats(day_first):\n        try:\n            # Parse, apply timezone, then apply PM offset if needed\n            dt = datetime.datetime.strptime(date_str, expression) - timezone + pm_delta\n            return calendar.timegm(dt.timetuple())\n        except ValueError:\n            continue\n\n    # Fallback: email.utils.parsedate_tz can handle things like \"14th\"\n    timetuple = email.utils.parsedate_tz(date_str)\n    if timetuple:\n        timestamp = calendar.timegm(timetuple[:9])\n        tzoffset = timetuple[9]\n        if tzoffset:\n            timestamp -= tzoffset\n        return timestamp\n\n    # Couldn't parse\n    return None"
    ]
  }
]